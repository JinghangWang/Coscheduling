From c25c95f91b00f0e2199bf15a11c18fa43b4ee519 Mon Sep 17 00:00:00 2001
From: Peter Dinda <pdinda@northwestern.edu>
Date: Wed, 19 Apr 2017 14:15:38 -0500
Subject: [PATCH 02/20] Track per-cpu interrupt nesting level and int/excp
 counts

The interrupt nesting level info makes it straightforward
for code to differentiate being called in interrupt context or
not
---
 include/nautilus/smp.h    |  5 ++++-
 src/asm/excp_early.S      | 13 +++++++++++++
 src/asm/thread_lowlevel.S |  8 ++++++++
 src/nautilus/scheduler.c  |  5 ++++-
 4 files changed, 29 insertions(+), 2 deletions(-)

diff --git a/include/nautilus/smp.h b/include/nautilus/smp.h
index 7c519bd..2e30c07 100644
--- a/include/nautilus/smp.h
+++ b/include/nautilus/smp.h
@@ -71,7 +71,10 @@ struct nk_xcall {
 #endif
 
 struct cpu {
-    struct nk_thread * cur_thread; /* KCH: this must be first! */
+    struct nk_thread * cur_thread;             /* +0  KCH: this must be first! */
+    uint16_t interrupt_nesting_level;          /* +8  PAD: DO NOT MOVE */
+    uint64_t interrupt_count;                  /* +16 PAD: DO NOT MOVE */
+    uint64_t exception_count;                  /* +24 PAD: DO NOT MOVE */
 
     cpu_id_t id;
     uint32_t lapic_id;   
diff --git a/src/asm/excp_early.S b/src/asm/excp_early.S
index 299af7c..30c796b 100644
--- a/src/asm/excp_early.S
+++ b/src/asm/excp_early.S
@@ -65,8 +65,13 @@ END(early_irq_handlers)
 .align 16
 GLOBAL(early_irq_common)
 
+    incw %gs:8   // increment interrupt nesting level -
+	         // cpu is now in interrupt context
+    incq %gs:16  // increment interrupt count
+
     SAVE_GPRS()
 
+
 #ifdef NAUT_CONFIG_PROFILE
     callq nk_irq_prof_enter
 #endif
@@ -104,6 +109,8 @@ GLOBAL(early_irq_common)
 thr_return:
     RESTORE_GPRS()
     addq $16, %rsp  // pop the vector and the error code
+    decw %gs:8      // decrement interrupt nesting level
+	            // we may now be outside of interrupt context
     iretq
 
 irq_err:
@@ -119,6 +126,10 @@ GLOBAL(early_excp_common)
 
     SAVE_GPRS()
 
+    incw %gs:8   // increment interrupt nesting level -
+	         // cpu is now in interrupt context 
+    incq %gs:24  // increment exception count
+	
     movq 120(%rsp), %rsi
     cmpq $32, %rsi
     jge excp_err
@@ -139,6 +150,8 @@ no_pf:
     RESTORE_GPRS()
     /* pop error code and excp number */
     addq $16, %rsp
+    decw %gs:8      // decrement interrupt nesting level
+	            // we may now be outside of interrupt context
     iretq
 
 excp_err:
diff --git a/src/asm/thread_lowlevel.S b/src/asm/thread_lowlevel.S
index fca633a..437f6a8 100644
--- a/src/asm/thread_lowlevel.S
+++ b/src/asm/thread_lowlevel.S
@@ -57,6 +57,10 @@ ENTRY(nk_thread_switch)
 
     SAVE_GPRS()
 
+    incw %gs:8           // increment interrupt nesting level
+	                 // pretend we are doing an interrupt-driven switch
+	                 // to make the sums work out
+	
 ENTRY(nk_thread_switch_intr_entry)
 
 #ifdef NAUT_CONFIG_PROFILE
@@ -66,6 +70,7 @@ ENTRY(nk_thread_switch_intr_entry)
 #endif
 
     movq %gs:0x0, %rax
+
     movq %rsp, (%rax)   /* save the current stack pointer */
 
 #ifdef NAUT_CONFIG_FPU_SAVE
@@ -94,6 +99,9 @@ ENTRY(nk_thread_switch_intr_entry)
 
     leaq 16(%rsp), %rsp /* pop off the vector and the error code */
 
+    decw %gs:8          // decrement interrupt nesting level -
+	                // we may now be leaving interrupt context
+
     iretq               /* and off we go */
 
 
diff --git a/src/nautilus/scheduler.c b/src/nautilus/scheduler.c
index 0d85dcd..a7561e9 100644
--- a/src/nautilus/scheduler.c
+++ b/src/nautilus/scheduler.c
@@ -516,9 +516,12 @@ void nk_sched_dump_cores(int cpu_arg)
 
 	    s = sys->cpus[cpu]->sched_state;
 	    LOCAL_LOCK(s);
-	    snprintf(buf,256,"%dc %s %lut %s %utp %lup %lur %lua %lum (%s) (%luul %lusp %luap %luaq %luadp) (%luapic)\n",
+	    snprintf(buf,256,"%dc %s %unl %luin %luex %lut %s %utp %lup %lur %lua %lum (%s) (%luul %lusp %luap %luaq %luadp) (%luapic)\n",
 		     cpu, 
 		     intr_model,
+		     sys->cpus[cpu]->interrupt_nesting_level,
+		     sys->cpus[cpu]->interrupt_count,
+		     sys->cpus[cpu]->exception_count,
 		     s->current->thread->tid, 
 		     s->current->thread->is_idle ? "(idle)" : s->current->thread->name[0] ? s->current->thread->name : "(noname)",
 		     s->current->thread->sched_state->constraints.interrupt_priority_class,
-- 
1.9.1

