From 3e91a158511333fac4bcc282c18ad0b08878e69a Mon Sep 17 00:00:00 2001
From: Peter Dinda <pdinda@northwestern.edu>
Date: Fri, 23 Jun 2017 06:21:27 -0500
Subject: [PATCH 13/20] Memory debugging enhancements and statistics

- sanity-checkers for kmem and buddy
- optional sanity checking on each malloc/free
- kmem/buddy statistics extraction
---
 include/nautilus/buddy.h  |  16 +++++-
 include/nautilus/mm.h     |  19 ++++++-
 src/nautilus/mm/boot_mm.c |   6 ++-
 src/nautilus/mm/buddy.c   |  94 ++++++++++++++++++++++++++++++----
 src/nautilus/mm/kmem.c    | 128 ++++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 249 insertions(+), 14 deletions(-)

diff --git a/include/nautilus/buddy.h b/include/nautilus/buddy.h
index 83dee6f..e349cbf 100644
--- a/include/nautilus/buddy.h
+++ b/include/nautilus/buddy.h
@@ -8,7 +8,7 @@
  * led by Sandia National Laboratories that includes several national 
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
- * http://xtack.sandia.gov/hobbes
+ * http://xstack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
  * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
@@ -50,6 +50,18 @@ struct buddy_mempool * buddy_init(ulong_t base_addr, ulong_t pool_order, ulong_t
 void buddy_free(struct buddy_mempool * mp, void * addr, ulong_t order);
 void * buddy_alloc(struct buddy_mempool * mp, ulong_t order);
 
-void buddy_dump_mempool(struct buddy_mempool *mp);
+int  buddy_sanity_check(struct buddy_mempool *mp);
+
+struct buddy_pool_stats {
+    void   *start_addr;
+    void   *end_addr;
+    uint64_t total_blocks_free;
+    uint64_t total_bytes_free;
+    uint64_t min_alloc_size;
+    uint64_t max_alloc_size;
+};
+
+void buddy_stats(struct buddy_mempool *mp, struct buddy_pool_stats *stats);
+
 
 #endif
diff --git a/include/nautilus/mm.h b/include/nautilus/mm.h
index 044120f..d6780bc 100644
--- a/include/nautilus/mm.h
+++ b/include/nautilus/mm.h
@@ -8,7 +8,7 @@
  * led by Sandia National Laboratories that includes several national 
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
- * http://xtack.sandia.gov/hobbes
+ * http://xstack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
  * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
@@ -25,6 +25,7 @@
 
 #include <nautilus/naut_types.h>
 #include <nautilus/list.h>
+#include <nautilus/buddy.h>
 
 #define MAX_MMAP_ENTRIES 128
 
@@ -88,12 +89,26 @@ void kmem_add_memory(struct mem_region * mem, ulong_t base_addr, size_t size);
 void * malloc(size_t size);
 void free(void * addr);
 
+int  kmem_sanity_check();
+
 
 /* arch specific */
 void arch_detect_mem_map (mmap_info_t * mm_info, mem_map_entry_t * memory_map, unsigned long mbd);
 void arch_reserve_boot_regions(unsigned long mbd);
 
 
-void kmem_dump_my_view();
+struct kmem_stats {
+    uint64_t total_num_pools; // how many memory pools there are
+    uint64_t total_blocks_free;
+    uint64_t total_bytes_free;
+    uint64_t min_alloc_size;
+    uint64_t max_alloc_size;
+    uint64_t max_pools;  // how many pools can we written in the following
+    uint64_t num_pools;   // how many pools were written in the following
+    struct buddy_pool_stats pool_stats[0];
+};
+
+uint64_t kmem_num_pools();
+void     kmem_stats(struct kmem_stats *stats);
 
 #endif /* !__MM_H__! */
diff --git a/src/nautilus/mm/boot_mm.c b/src/nautilus/mm/boot_mm.c
index 074295b..512c464 100644
--- a/src/nautilus/mm/boot_mm.c
+++ b/src/nautilus/mm/boot_mm.c
@@ -8,7 +8,7 @@
  * led by Sandia National Laboratories that includes several national 
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
- * http://xtack.sandia.gov/hobbes
+ * http://xstack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
  * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
@@ -224,6 +224,8 @@ mm_boot_reserve_mem (addr_t start, ulong_t size)
     uint32_t npages     = (size+PAGE_SIZE-1) / PAGE_SIZE;
     boot_mem_info_t * bm = &bootmem;
 
+    BMM_DEBUG("Reserving memory %p-%p (start page=0x%x, npages=0x%x)\n",start,start+size,start_page,npages);
+
     if (unlikely(boot_mm_inactive)) {
         panic("Invalid attempt to use boot memory allocator\n");    
     }
@@ -371,6 +373,8 @@ found:
             panic("bit %u not set!\n", i);
     }
 
+    BMM_DEBUG("Allocated %d bytes, alignment %d (%d pages) at %p\n", size, align, areasize, ret);
+
     /* NOTE: we do NOT zero the memory! */
     return (void*)pa_to_va((ulong_t)ret);
 }
diff --git a/src/nautilus/mm/buddy.c b/src/nautilus/mm/buddy.c
index 43954d6..910c82e 100644
--- a/src/nautilus/mm/buddy.c
+++ b/src/nautilus/mm/buddy.c
@@ -234,6 +234,7 @@ buddy_init (ulong_t base_addr,
 	return NULL;
     }
 
+
     /* Initially all lists are empty */
     for (i = 0; i <= pool_order; i++) {
         INIT_LIST_HEAD(&mp->avail[i]);
@@ -320,7 +321,7 @@ buddy_alloc (struct buddy_mempool *mp, ulong_t order)
             list_add(&buddy_block->link, &mp->avail[j]);
         }
 
-	BUDDY_DEBUG("Returning block %p\n",block);
+	BUDDY_DEBUG("Returning block %p which is in memory pool %p-%p\n",block,mp->base_addr,mp->base_addr+(1ULL << mp->pool_order));
 
         return block;
     }
@@ -348,13 +349,19 @@ buddy_free(
     ASSERT(order <= mp->pool_order);
     ASSERT(!((uint64_t)addr % (1ULL<<order)));  // aligned to own size only
 
-    BUDDY_DEBUG("BUDDY FREE on memory pool: %p addr=%p order=%lu\n",mp,addr,order);
+    BUDDY_DEBUG("BUDDY FREE on memory pool: %p addr=%p base=%p order=%lu\n",mp,addr,mp->base_addr, order);
 
     /* Fixup requested order to be at least the minimum supported */
     if (order < mp->min_order) {
         order = mp->min_order;
 	BUDDY_DEBUG("updated order to %lu\n",order);
     }
+
+    ASSERT((uint64_t)addr>=(uint64_t)(mp->base_addr) &&
+	   (uint64_t)addr<(uint64_t)(mp->base_addr+(1ULL<<mp->pool_order)));
+
+    ASSERT(order<=mp->pool_order);
+
     /* Overlay block structure on the memory block being freed */
     struct block * block = (struct block *) addr;
 
@@ -413,25 +420,94 @@ buddy_free(
 }
 
 
-/**
- * Dumps the state of a buddy system memory allocator object to the console.
+/*
+  Sanity-checks and gets statistics of the buddy pool
  */
-void
-buddy_dump_mempool(struct buddy_mempool *mp)
+static int _buddy_sanity_check(struct buddy_mempool *mp, struct buddy_pool_stats *stats)
 {
+    int rc;
     ulong_t i;
     ulong_t num_blocks;
+    uint64_t total_bytes;
+    uint64_t total_blocks;
+    uint64_t min_alloc, max_alloc;
+    uint8_t flags;
     struct list_head *entry;
 
-    BUDDY_DEBUG("DUMP OF BUDDY MEMORY POOL:\n");
+    rc=0;
+
+    flags = spin_lock_irq_save(&mp->lock);
+
+    stats->start_addr = (void*)(mp->base_addr);
+    stats->end_addr = (void*)(mp->base_addr + (1ULL<<mp->pool_order));
+
+    total_bytes = 0;
+    total_blocks = 0;
+    min_alloc = 0;
+    max_alloc = 0;
+
+    //nk_vc_printf("buddy pool %p-%p, order=%lu, min order=%lu\n", mp->base_addr, mp->base_addr + (1ULL<<mp->pool_order),mp->pool_order,mp->min_order);
 
     for (i = mp->min_order; i <= mp->pool_order; i++) {
 
         /* Count the number of memory blocks in the list */
         num_blocks = 0;
-        list_for_each(entry, &mp->avail[i])
+        list_for_each(entry, &mp->avail[i])  {
+	    struct block *block = list_entry(entry, struct block, link);
+	    //nk_vc_printf("order %lu block %lu\n",i, num_blocks);
+	    //nk_vc_printf("entry %p - block %p order %lx\n",entry, block,block->order);
+	    if ((uint64_t)block<(uint64_t)mp->base_addr || 
+		(uint64_t)block>=(uint64_t)(mp->base_addr+(1ULL<<mp->pool_order))) { 
+		ERROR_PRINT("BLOCK %p IS OUTSIDE OF POOL RANGE (%p-%p)\n", block,
+			    mp->base_addr,(mp->base_addr+(1ULL<<mp->pool_order)));
+		rc|=-1;
+		break;
+	    }
+	    if (block->order != i) { 
+		ERROR_PRINT("BLOCK %p IS OF INCORRECT ORDER (%lu)\n", block, block->order);
+		ERROR_PRINT("FIRST WORDS: 0x%016lx 0x%016lx 0x%016lx 0x%016lx\n", ((uint64_t*)block)[0],((uint64_t*)block)[1],((uint64_t*)block)[2],((uint64_t*)block)[3]);
+		rc|=-1;
+		break;
+	    }
+	    if (!is_available(mp,block)) { 
+		ERROR_PRINT("BLOCK %p IS NOT MARKED AVAILABLE BUT IS ON FREE LIST\n", block);
+		ERROR_PRINT("FIRST WORDS: 0x%016lx 0x%016lx 0x%016lx 0x%016lx\n", ((uint64_t*)block)[0],((uint64_t*)block)[1],((uint64_t*)block)[2],((uint64_t*)block)[3]);
+		rc|=-1;
+		break;
+	    }
             ++num_blocks;
+	}
+
+	//nk_vc_printf("%lu blocks at order %lu\n",num_blocks,i);
 
-        BUDDY_DEBUG("  order %2lu: %lu free blocks\n", i, num_blocks);
+	if (min_alloc==0) { 
+	    min_alloc = 1ULL << mp->min_order ;
+	}
+	if (num_blocks>0) { 
+	    max_alloc = 1ULL << i;
+	}
+
+	total_blocks += num_blocks;
+	total_bytes += num_blocks * (1ULL << i);
     }
+    
+    stats->total_blocks_free = total_blocks;
+    stats->total_bytes_free = total_bytes;
+    stats->min_alloc_size = min_alloc;
+    stats->max_alloc_size = max_alloc;
+    
+    spin_unlock_irq_restore(&mp->lock,flags);
+
+    return rc;
+}
+
+void buddy_stats(struct buddy_mempool *mp, struct buddy_pool_stats *stats)
+{
+    _buddy_sanity_check(mp,stats);
+}
+
+int buddy_sanity_check(struct buddy_mempool *mp)
+{
+    struct buddy_pool_stats s;
+    return _buddy_sanity_check(mp,&s);
 }
diff --git a/src/nautilus/mm/kmem.c b/src/nautilus/mm/kmem.c
index 18e8d7a..a3bb337 100644
--- a/src/nautilus/mm/kmem.c
+++ b/src/nautilus/mm/kmem.c
@@ -39,11 +39,24 @@
 #define DEBUG_PRINT(fmt, args...)
 #endif
 
+#include <nautilus/backtrace.h>
+
+// turn this on to have a sanity check run before and after each
+// malloc and free
+#define SANITY_CHECK_PER_OP 0
+
 #define KMEM_DEBUG(fmt, args...) DEBUG_PRINT("KMEM: " fmt, ##args)
 #define KMEM_ERROR(fmt, args...) ERROR_PRINT("KMEM: " fmt, ##args)
 #define KMEM_PRINT(fmt, args...) INFO_PRINT("KMEM: " fmt, ##args)
 #define KMEM_WARN(fmt, args...)  WARN_PRINT("KMEM: " fmt, ##args)
 
+#ifndef NAUT_CONFIG_DEBUG_KMEM
+#define KMEM_DEBUG_BACKTRACE()
+#else
+#define KMEM_DEBUG_BACKTRACE() BACKTRACE(KMEM_DEBUG,3)
+#endif	
+	    
+
 /**
  * This specifies the minimum sized memory block to request from the underlying
  * buddy system memory allocator, 2^MIN_ORDER bytes. It must be at least big
@@ -448,6 +461,16 @@ malloc (size_t size)
     cpu_id_t my_id = my_cpu_id();
     struct kmem_data * my_kmem = &(nk_get_nautilus_info()->sys.cpus[my_id]->kmem);
 
+    KMEM_DEBUG("malloc of %lu bytes from:\n",size);
+    KMEM_DEBUG_BACKTRACE();
+
+#if SANITY_CHECK_PER_OP
+    if (kmem_sanity_check()) { 
+	panic("KMEM HAS GONE INSANE PRIOR TO MALLOC\n");
+	return 0;
+    }
+#endif
+
 
     /* Calculate the block order needed */
     order = ilog2(roundup_pow_of_two(size));
@@ -467,7 +490,11 @@ malloc (size_t size)
 	if (block) {
 	  hdr = block_hash_alloc(block);
 	  if (!hdr) {
+            KMEM_DEBUG("malloc cannot allocate header, releasing block\n");
+	    flags = spin_lock_irq_save(&zone->lock);
 	    buddy_free(zone,block,order);
+	    spin_unlock_irq_restore(&zone->lock, flags);
+	    block=0;
 	  }
 	}
 
@@ -483,9 +510,19 @@ malloc (size_t size)
     if (hdr) {
         kmem_bytes_allocated += (1UL << order);
     } else {
+	KMEM_DEBUG("malloc failed for size %lu order %lu\n",size,order);
         return NULL;
     }
 
+    KMEM_DEBUG("malloc succeeded: size %lu order %lu -> 0x%lx\n",size, order, block);
+      
+#if SANITY_CHECK_PER_OP
+    if (kmem_sanity_check()) { 
+	panic("KMEM HAS GONE INSANE AFTER MALLOC\n");
+	return 0;
+    }
+#endif
+
     /* Return address of the block */
     return block;
 }
@@ -508,6 +545,16 @@ free (void * addr)
     struct kmem_block_hdr *hdr;
     struct buddy_mempool * zone;
 
+    KMEM_DEBUG("free of address %p from:\n", addr);
+    KMEM_DEBUG_BACKTRACE();
+
+#if SANITY_CHECK_PER_OP
+    if (kmem_sanity_check()) { 
+	panic("KMEM HAS GONE INSANE PRIOR TO FREE\n");
+	return;
+    }
+#endif
+
     if (!addr) {
         return;
     }
@@ -526,6 +573,87 @@ free (void * addr)
     kmem_bytes_allocated -= (1UL << hdr->order);
     buddy_free(zone, addr, hdr->order);
     spin_unlock_irq_restore(&zone->lock, flags);
+    KMEM_DEBUG("free succeeded: addr=0x%lx order=%lu\n",addr,hdr->order);
     block_hash_free_entry(hdr);
+
+#if SANITY_CHECK_PER_OP
+    if (kmem_sanity_check()) { 
+	panic("KMEM HAS GONE INSANE AFTER FREE\n");
+	return;
+    }
+#endif
+
 }
 
+
+typedef enum {GET,COUNT} stat_type_t;
+
+static uint64_t _kmem_stats(struct kmem_stats *stats, stat_type_t what)
+{
+    uint64_t cur;
+    struct mem_reg_entry * reg = NULL;
+    struct kmem_data * my_kmem = &(nk_get_nautilus_info()->sys.cpus[my_cpu_id()]->kmem);
+    if (what==GET) { 
+	uint64_t num = stats->max_pools;
+	memset(stats,0,sizeof(*stats));
+	stats->min_alloc_size=-1;
+	stats->max_pools = num;
+    }
+
+    // We will scan all memory from the current CPU's perspective
+    // Since every CPUs sees all memory pools (albeit in NUMA order)
+    // this will cover all memory
+    cur = 0;
+    list_for_each_entry(reg, &(my_kmem->ordered_regions), mem_ent) {
+	if (what==GET) { 
+	    struct buddy_mempool * zone = reg->mem->mm_state;
+	    struct buddy_pool_stats pool_stats;
+	    buddy_stats(zone,&pool_stats);
+	    if (cur<stats->max_pools) { 
+		stats->pool_stats[cur] = pool_stats;
+		stats->num_pools++;
+	    }
+	    stats->total_blocks_free += pool_stats.total_blocks_free;
+	    stats->total_bytes_free += pool_stats.total_bytes_free;
+	    if (pool_stats.min_alloc_size < stats->min_alloc_size) { 
+		stats->min_alloc_size = pool_stats.min_alloc_size;
+	    }
+	    if (pool_stats.max_alloc_size > stats->max_alloc_size) { 
+		stats->max_alloc_size = pool_stats.max_alloc_size;
+	    }
+	}
+	cur++;
+    }
+    stats->total_num_pools=cur;
+    return cur;
+}
+
+
+uint64_t kmem_num_pools()
+{
+    return _kmem_stats(0,COUNT);
+}
+
+void kmem_stats(struct kmem_stats *stats)
+{
+    _kmem_stats(stats,GET);
+}
+
+int kmem_sanity_check()
+{
+    int rc=0;
+    uint64_t cur;
+    struct mem_reg_entry * reg = NULL;
+    struct kmem_data * my_kmem = &(nk_get_nautilus_info()->sys.cpus[my_cpu_id()]->kmem);
+
+    list_for_each_entry(reg, &(my_kmem->ordered_regions), mem_ent) {
+	struct buddy_mempool * zone = reg->mem->mm_state;
+	if (buddy_sanity_check(zone)) { 
+	    ERROR_PRINT("buddy memory pool %p is insane\n", zone);
+	    rc|=-1;
+	}
+    }
+
+    return rc;
+}
+    
-- 
1.9.1

