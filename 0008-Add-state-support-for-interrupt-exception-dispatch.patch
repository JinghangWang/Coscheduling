From e84e01250ae99d0abb7a11e97cffb4224ac9a2c6 Mon Sep 17 00:00:00 2001
From: Peter Dinda <pdinda@northwestern.edu>
Date: Sun, 21 May 2017 16:53:21 -0500
Subject: [PATCH 08/20] Add state support for interrupt/exception dispatch

- Interrupt handlers and exception handlers now dispatch
  with an additional argument - a state pointer supplied
  when the idt entry is made
---
 include/nautilus/idt.h |  9 ++++++---
 src/asm/excp_early.S   | 28 ++++++++++++++++++++--------
 src/nautilus/idt.c     | 41 ++++++++++++++++++++++++++++++-----------
 3 files changed, 56 insertions(+), 22 deletions(-)

diff --git a/include/nautilus/idt.h b/include/nautilus/idt.h
index 4494880..f36ba4e 100644
--- a/include/nautilus/idt.h
+++ b/include/nautilus/idt.h
@@ -121,9 +121,12 @@ struct idt_desc {
 
 
 int setup_idt(void);
-int idt_assign_entry(ulong_t entry, ulong_t handler_addr);
-int null_excp_handler(excp_entry_t * excp, excp_vec_t vec, addr_t fault_addr);
-int null_irq_handler(excp_entry_t * excp, excp_vec_t vector);
+
+int idt_assign_entry(ulong_t entry, ulong_t handler_addr, ulong_t state_addr);
+int idt_get_entry(ulong_t entry, ulong_t *handler_addr, ulong_t *state_addr);
+
+int null_excp_handler(excp_entry_t * excp, excp_vec_t vec, addr_t fault_addr, void * state_addr);
+int null_irq_handler(excp_entry_t * excp, excp_vec_t vector, void * state_addr);
 
 static inline void
 write_gate_desc (struct   gate_desc64 * idt,
diff --git a/src/asm/excp_early.S b/src/asm/excp_early.S
index 30c796b..b1af475 100644
--- a/src/asm/excp_early.S
+++ b/src/asm/excp_early.S
@@ -78,8 +78,11 @@ GLOBAL(early_irq_common)
 
     leaq 128(%rsp), %rdi # pointer to exception struct
     movq 120(%rsp), %rsi # irq num
-    movabs $handler_table, %rdx
-    movq (%rdx, %rsi, 8), %rcx
+    movabs $idt_handler_table, %rdx
+    movq (%rdx, %rsi, 8), %r8   # pointer to handler
+    movabs $idt_state_table, %rdx
+    movq (%rdx, %rsi, 8), %rdx   # pointer to state
+	
     
 #ifdef NAUT_CONFIG_ENABLE_ASSERTS
     cmpq $256, %rsi
@@ -89,7 +92,7 @@ GLOBAL(early_irq_common)
     jl irq_err
 #endif
 
-    callq *%rcx
+    callq *%r8    # rdi = exp struct, rsi = irq num, rdx = state
 
     testq %rax, %rax
     jnz irq_err
@@ -136,14 +139,16 @@ GLOBAL(early_excp_common)
 
     leaq 128(%rsp), %rdi # pointer to exception struct
     movq 120(%rsp), %rsi # excp vector
-    movabs $handler_table, %rdx
-    movq (%rdx, %rsi, 8), %rcx
+    movabs $idt_handler_table, %rdx
+    movq (%rdx, %rsi, 8), %r8   # pointer to handler
+    movabs $idt_state_table, %rdx
+    movq (%rdx, %rsi, 8), %rcx   # pointer to state
     cmpq $14, %rsi
     jnz no_pf
     movq %cr2, %rdx
 
 no_pf:
-    callq *%rcx
+    callq *%r8   # rdi = exp struct, rsi = irq num, rdx = error, rcx = state
     testq %rax, %rax
     jnz excp_err
 
@@ -164,7 +169,7 @@ loop1:
 
 
 .align 8
-GLOBAL(handler_table)
+GLOBAL(idt_handler_table)
 .rept NUM_EXCEPTIONS
     .quad null_excp_handler
 .endr
@@ -172,7 +177,14 @@ GLOBAL(handler_table)
 .rept NUM_IDT_ENTRIES - NUM_EXCEPTIONS
     .quad null_irq_handler
 .endr
-END(handler_table)
+END(idt_handler_table)
+
+.align 8
+GLOBAL(idt_state_table)
+.rept NUM_IDT_ENTRIES
+    .quad 0
+.endr
+END(idt_state_table)
 
 
 irq_err_str:
diff --git a/src/nautilus/idt.c b/src/nautilus/idt.c
index 473a4a0..6fe88a9 100644
--- a/src/nautilus/idt.c
+++ b/src/nautilus/idt.c
@@ -8,7 +8,7 @@
  * led by Sandia National Laboratories that includes several national 
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
- * http://xtack.sandia.gov/hobbes
+ * http://xstack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
  * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
@@ -31,7 +31,8 @@
 #include <nautilus/irq.h>
 #include <nautilus/backtrace.h>
 
-extern ulong_t handler_table[NUM_IDT_ENTRIES];
+extern ulong_t idt_handler_table[NUM_IDT_ENTRIES];
+extern ulong_t idt_state_table[NUM_IDT_ENTRIES]; 
 
 struct gate_desc64 idt64[NUM_IDT_ENTRIES] __align(8);
 
@@ -85,7 +86,8 @@ struct idt_desc idt_descriptor =
 int 
 null_excp_handler (excp_entry_t * excp,
                    excp_vec_t vector,
-                   addr_t fault_addr)
+                   addr_t fault_addr,
+		   void *state)
 {
     cpu_id_t cpu_id = cpu_info_ready ? my_cpu_id() : 0xffffffff;
     /* TODO: this should be based on scheduler initialization, not CPU */
@@ -120,7 +122,8 @@ null_excp_handler (excp_entry_t * excp,
 
 int
 null_irq_handler (excp_entry_t * excp,
-                  excp_vec_t vector)
+                  excp_vec_t vector,
+		  void       *state)
 {
     printk("[Unhandled IRQ] (vector=0x%x)\n    RIP=(%p)     (core=%u)\n", 
             vector,
@@ -159,7 +162,7 @@ pic_spur_int_handler (excp_entry_t * excp,
 
 
 int
-idt_assign_entry (ulong_t entry, ulong_t handler_addr)
+idt_assign_entry (ulong_t entry, ulong_t handler_addr, ulong_t state_addr)
 {
 
     if (entry >= NUM_IDT_ENTRIES) {
@@ -172,7 +175,23 @@ idt_assign_entry (ulong_t entry, ulong_t handler_addr)
         return -1;
     }
 
-    handler_table[entry] = handler_addr;
+    idt_handler_table[entry] = handler_addr;
+    idt_state_table[entry]   = state_addr;
+
+    return 0;
+}
+
+int
+idt_get_entry (ulong_t entry, ulong_t *handler_addr, ulong_t *state_addr)
+{
+
+    if (entry >= NUM_IDT_ENTRIES) {
+        ERROR_PRINT("Getting invalid IDT entry\n");
+        return -1;
+    }
+
+    *handler_addr = idt_handler_table[entry];
+    *state_addr = idt_state_table[entry];
 
     return 0;
 }
@@ -194,25 +213,25 @@ setup_idt (void)
 
     for (i = 0; i < NUM_EXCEPTIONS; i++) {
         set_intr_gate(idt64, i, (void*)(excp_start + i*16));
-        idt_assign_entry(i, (ulong_t)null_excp_handler);
+        idt_assign_entry(i, (ulong_t)null_excp_handler, 0);
     }
 
     for (i = 32; i < NUM_IDT_ENTRIES; i++) {
         set_intr_gate(idt64, i, (void*)(irq_start + (i-32)*16));
-        idt_assign_entry(i, (ulong_t)null_irq_handler);
+        idt_assign_entry(i, (ulong_t)null_irq_handler, 0);
     }
 
-    if (idt_assign_entry(PF_EXCP, (ulong_t)nk_pf_handler) < 0) {
+    if (idt_assign_entry(PF_EXCP, (ulong_t)nk_pf_handler, 0) < 0) {
         ERROR_PRINT("Couldn't assign page fault handler\n");
         return -1;
     }
 
-    if (idt_assign_entry(DF_EXCP, (ulong_t)df_handler) < 0) {
+    if (idt_assign_entry(DF_EXCP, (ulong_t)df_handler, 0) < 0) {
         ERROR_PRINT("Couldn't assign double fault handler\n");
         return -1;
     }
 
-    if (idt_assign_entry(0xf, (ulong_t)pic_spur_int_handler) < 0) {
+    if (idt_assign_entry(0xf, (ulong_t)pic_spur_int_handler, 0) < 0) {
         ERROR_PRINT("Couldn't assign PIC spur int handler\n");
         return -1;
     }
-- 
1.9.1

