From 54e00c66891d3cc5272683598900f96d36ff13bf Mon Sep 17 00:00:00 2001
From: Peter Dinda <pdinda@northwestern.edu>
Date: Fri, 23 Jun 2017 06:00:52 -0500
Subject: [PATCH 12/20] Improved debug/logging output format and compiler-based
 backtrace facility

---
 include/nautilus/backtrace.h |  49 +++++++++++++++++++-
 include/nautilus/nautilus.h  | 108 +++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 152 insertions(+), 5 deletions(-)

diff --git a/include/nautilus/backtrace.h b/include/nautilus/backtrace.h
index 83dedd3..1e18598 100644
--- a/include/nautilus/backtrace.h
+++ b/include/nautilus/backtrace.h
@@ -8,7 +8,7 @@
  * led by Sandia National Laboratories that includes several national 
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
- * http://xtack.sandia.gov/hobbes
+ * http://xstack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
  * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
@@ -44,6 +44,53 @@ void nk_dump_mem(void *, ulong_t);
 void nk_stack_dump(ulong_t);
 void nk_print_regs(struct nk_regs * r);
 
+// backtrace facility using compiler builtins
+#define IS_CANONICAL(x) ((((uint64_t)(x))<0x0000800000000000ULL) || (((uint64_t)(x))>=0xffff800000000000ULL))
+#define IN_PHYS_MEM(x) (((uint64_t)(x)) < nk_get_nautilus_info()->sys.mem.phys_mem_avail)
+#define IS_VALID(x)   ((x) && IS_CANONICAL(x))
+#define BACKTRACE(print_func,limit)			\
+do {							\
+    void *_cur = __builtin_return_address(0);		\
+    if (IS_VALID(_cur) && limit==0) {			\
+        print_func("%p\n",_cur);                        \
+    }                                                   \
+    if (IS_VALID(_cur) && limit>0) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(1);		\
+    }							\
+    if (IS_VALID(_cur) && limit>1) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(2);		\
+    }							\
+    if (IS_VALID(_cur) && limit>2) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(3);		\
+    }							\
+    if (IS_VALID(_cur) && limit>3) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(5);		\
+    }							\
+    if (IS_VALID(_cur) && limit>4) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(6);		\
+    }							\
+    if (IS_VALID(_cur) && limit>5) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(7);		\
+    }							\
+    if (IS_VALID(_cur) && limit>6) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(8);		\
+    }							\
+    if (IS_VALID(_cur) && limit>7) {			\
+	print_func("%p\n",_cur);			\
+	_cur = __builtin_return_address(9);		\
+    }							\
+    if (IS_VALID(_cur) && limit>8) {			\
+	print_func("%p [additional frames ignored]\n",_cur);	\
+    }							\
+ } while (0)						
+
 
 #ifdef __cplusplus
 }
diff --git a/include/nautilus/nautilus.h b/include/nautilus/nautilus.h
index c1b491b..6c3254c 100644
--- a/include/nautilus/nautilus.h
+++ b/include/nautilus/nautilus.h
@@ -28,16 +28,116 @@
 #include <dev/serial.h>
 #include <nautilus/naut_types.h>
 #include <nautilus/instrument.h>
+#include <nautilus/smp.h>
+#include <nautilus/thread.h>
 #include <nautilus/vc.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#define DEBUG_PRINT(fmt, args...)   nk_vc_log_wrap("CPU %d: DEBUG: " fmt, my_cpu_id(),##args)
-#define ERROR_PRINT(fmt, args...)   nk_vc_log_wrap("CPU %d: ERROR at %s(%lu): " fmt, my_cpu_id(),  __FILE__, __LINE__, ##args)
-#define WARN_PRINT(fmt, args...)    nk_vc_log_wrap("CPU %d: WARNING: " fmt, my_cpu_id(), ##args)
-#define INFO_PRINT(fmt, args...)    nk_vc_log_wrap("CPU %d: " fmt, my_cpu_id(), ##args)
+#define DEBUG_PRINT(fmt, args...)					\
+do {									\
+    if (__cpu_state_get_cpu()) {					\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+	struct nk_thread *_t = get_cur_thread();				\
+ 	nk_vc_log_wrap("CPU %d (%s%s %lu \"%s\"): DEBUG: " fmt,		\
+		       my_cpu_id(),					\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+		       _t ? _t->tid : 0,				\
+		       _t ? _t->is_idle ? "*idle*" : _t->name[0]==0 ? "*unnamed*" : _t->name : "*none*", \
+		       ##args);						\
+	preempt_enable();						\
+    } else {								\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+ 	nk_vc_log_wrap("CPU ? (%s%s): DEBUG: " fmt,			\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+		       ##args);						\
+	preempt_enable();						\
+    }									\
+} while (0)
+
+#define ERROR_PRINT(fmt, args...)					\
+do {									\
+    if (__cpu_state_get_cpu()) {					\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+	struct nk_thread *_t = get_cur_thread();				\
+ 	nk_vc_log_wrap("CPU %d (%s%s %lu \"%s\"): ERROR at %s(%lu): " fmt,		\
+		       my_cpu_id(),					\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+		       _t ? _t->tid : 0,					\
+		       _t ? _t->is_idle ? "*idle*" : _t->name[0]==0 ? "*unnamed*" : _t->name : "*none*", \
+	               __FILE__,__LINE__,                               \
+		       ##args);						\
+	preempt_enable();						\
+    } else {								\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+ 	nk_vc_log_wrap("CPU ? (%s%s): ERROR at %s(%lu): " fmt,			\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+                       __FILE__,__LINE__,                               \
+		       ##args);						\
+	preempt_enable();						\
+    }									\
+} while (0)
+
+
+#define WARN_PRINT(fmt, args...)					\
+do {									\
+    if (__cpu_state_get_cpu()) {					\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+	struct nk_thread *_t = get_cur_thread();				\
+ 	nk_vc_log_wrap("CPU %d (%s%s %lu \"%s\"): WARNING : " fmt,	        \
+		       my_cpu_id(),					\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+		       _t ? _t->tid : 0,					\
+		       _t ? _t->is_idle ? "*idle*" : _t->name[0]==0 ? "*unnamed*" : _t->name : "*none*", \
+		       ##args);						\
+	preempt_enable();						\
+    } else {								\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+ 	nk_vc_log_wrap("CPU ? (%s%s): WARNING: " fmt,			\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+		       ##args);						\
+	preempt_enable();						\
+    }									\
+} while (0)
+
+#define INFO_PRINT(fmt, args...)					\
+do {									\
+    if (__cpu_state_get_cpu()) {					\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+	struct nk_thread *_t = get_cur_thread();				\
+ 	nk_vc_log_wrap("CPU %d (%s%s %lu \"%s\"): " fmt,	        \
+		       my_cpu_id(),					\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+		       _t ? _t->tid : 0,					\
+		       _t ? _t->is_idle ? "*idle*" : _t->name[0]==0 ? "*unnamed*" : _t->name : "*none*", \
+		       ##args);						\
+	preempt_enable();						\
+    } else {								\
+	int _p=preempt_is_disabled();					\
+	preempt_disable();						\
+ 	nk_vc_log_wrap("CPU ? (%s%s): " fmt,       			\
+		       in_interrupt_context() ? "I" :"",		\
+		       _p ? "" : "P",					\
+		       ##args);						\
+	preempt_enable();						\
+    }									\
+} while (0)
 
 #define panic(fmt, args...)         panic("PANIC at %s(%d): " fmt, __FILE__, __LINE__, ##args)
 
-- 
1.9.1

